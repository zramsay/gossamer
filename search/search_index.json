{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A Go Implementation of the Polkadot Host \u00b6 Gossamer is an implementation of the Polkadot Host : a framework used to build and run nodes for different blockchain protocols that are compatible with the Polkadot ecosystem. The core of the Polkadot Host is the wasm runtime which handles the logic of the chain. Gossamer includes node implementations for major blockchains within the Polkadot ecosystem and simplifies building node implementations for other blockchains. Runtimes built with Substrate can plug their runtime into Gossamer to create a node implementation in Go. Gossamer Docs is an evolving set of documents and resources to help you understand Gossamer, the Polkadot ecosystem, and how to build and run nodes using Gossamer. If you are new to Gossamer and the Polkadot ecosystem, we recommend starting with this video and then working your way through General Resources . If you are already familiar with Gossamer and the Polkadot ecosystem, or you just want to dive in, head over to Get Started to run your first node using Gossamer. If you are looking to build a node with Gossamer, learn how Gossamer can be used to build and run custom node implementations using Gossamer as a framework (keep reading). Framework \u00b6 Gossamer is a modular blockchain framework used to build and run nodes for different blockchain protocols within the Polkadot ecosystem. The simplest way to use the framework is using the base node implementation with a custom configuration file (see Configuration ). The more advanced way to use the framework is using the base node implementation with a compiled runtime and custom runtime imports (see Import Runtime ). Our primary focus has been an initial implementation of the Polkadot Host. Once we feel confident our initial implementation is fully operational and secure, we will expand the Gossamer framework to include a runtime library and other tools and services that will enable Go developers to build, test, and run custom-built blockchain protocols within the Polkadot ecosystem. Connect \u00b6 Let us know if you have any feedback or ideas that might help us improve our documentation or if you have any resources that you would like to see added. If you are planning to use Gossamer or any of the Gossamer packages, please say hello! You can find us on Discord .","title":"Overview"},{"location":"#a-go-implementation-of-the-polkadot-host","text":"Gossamer is an implementation of the Polkadot Host : a framework used to build and run nodes for different blockchain protocols that are compatible with the Polkadot ecosystem. The core of the Polkadot Host is the wasm runtime which handles the logic of the chain. Gossamer includes node implementations for major blockchains within the Polkadot ecosystem and simplifies building node implementations for other blockchains. Runtimes built with Substrate can plug their runtime into Gossamer to create a node implementation in Go. Gossamer Docs is an evolving set of documents and resources to help you understand Gossamer, the Polkadot ecosystem, and how to build and run nodes using Gossamer. If you are new to Gossamer and the Polkadot ecosystem, we recommend starting with this video and then working your way through General Resources . If you are already familiar with Gossamer and the Polkadot ecosystem, or you just want to dive in, head over to Get Started to run your first node using Gossamer. If you are looking to build a node with Gossamer, learn how Gossamer can be used to build and run custom node implementations using Gossamer as a framework (keep reading).","title":"A Go Implementation of the Polkadot Host"},{"location":"#framework","text":"Gossamer is a modular blockchain framework used to build and run nodes for different blockchain protocols within the Polkadot ecosystem. The simplest way to use the framework is using the base node implementation with a custom configuration file (see Configuration ). The more advanced way to use the framework is using the base node implementation with a compiled runtime and custom runtime imports (see Import Runtime ). Our primary focus has been an initial implementation of the Polkadot Host. Once we feel confident our initial implementation is fully operational and secure, we will expand the Gossamer framework to include a runtime library and other tools and services that will enable Go developers to build, test, and run custom-built blockchain protocols within the Polkadot ecosystem.","title":"Framework"},{"location":"#connect","text":"Let us know if you have any feedback or ideas that might help us improve our documentation or if you have any resources that you would like to see added. If you are planning to use Gossamer or any of the Gossamer packages, please say hello! You can find us on Discord .","title":"Connect"},{"location":"contributing/","text":"Contribution Guidelines \u00b6 Thank you for your interest in our implementation of the Polkadot Runtime Environment Implementation! We're excited to get to know you and work with you on gossamer. We've put together these guidelines to help you figure out how you can help us. At any point in this process feel free to reach out on Discord with any questions or to say Hello :) Getting Started \u00b6 Generally, it is important to have a basic understanding of Polkadot and the Polkadot Runtime Environment. Having a stronger understanding will allow you to make more significant contributions. We've put together a list of resources that can help you develop this fundamental knowledge. The Web3 Foundation has a Polkadot Wiki that would help both part-time and core contributors to the project in order to get up to speed. Our wiki also has some helpful resources. The Polkadot Runtime Specification serves as our primary specification, however it is currently in its draft status so things may be subject to change. One important thing distinction is that we are building the Polkadot Runtime Environment, not Polkadot itself. Given that, although a deep understanding of Polkadot is helpful, it's not critical to contribute to gossamer. To help understand how the Runtime Environment relates to Polkadot, check out this talk that one of our team members gave at DotCon. Contribution Steps \u00b6 1. Fork the gossamer repo. 2. Create a local clone of gossamer. go get - u github . com / ChainSafe / gossamer cd $ GOPATH / src / github . com / ChainSafe / gossamer git init You may encounter a package github.com/ChainSafe/gossamer: no Go files in ... message when doing go get . This is not an error, since there are no go files in the project root. 3. Link your local clone to the fork on your Github repo. $ git remote add your-gossamer-repo https://github.com/<your_github_user_name>/gossamer.git 4. Link your local clone to the ChainSafe Systems repo so that you can easily fetch future changes to the ChainSafe Systems repo. $ git remote add gossamer https://github.com/ChainSafe/gossamer.git $ git remote -v ( you should see myrepo and gossamer in the list of remotes ) 5. Find something to work on. To start, check out our open issues. We recommend starting with an issue labeled Good First Issue . Leave a comment to let us know that you would like to work on it. Another option is to improve gossamer where you see fit based on your evaluation of our code. In order to best facilitate collaboration, please create an issue before you start working on it. 6. Make improvements to the code. Each time you work on the code be sure that you are working on the branch that you have created as opposed to your local copy of the gossamer repo. Keeping your changes segregated in this branch will make it easier to merge your changes into the repo later. $ git checkout feature-in-progress-branch 7. Test your changes. Changes that only affect a single file can be tested with $ go test <file_you_are_working_on> 8. Lint your changes. Before opening a pull request be sure to run the linter $ make lint 9. Create a pull request. Navigate your browser to https://github.com/ChainSafe/gossamer and click on the new pull request button. In the \u201cbase\u201d box on the left, change the branch to \u201c base development \u201d, the branch that you want your changes to be applied to. In the \u201ccompare\u201d box on the right, select feature-in-progress-branch, the branch containing the changes you want to apply. You will then be asked to answer a few questions about your pull request. After you complete the questionnaire, the pull request will appear in the list of pull requests at https://github.com/ChainSafe/gossamer/pulls . Note on memory intensive tests \u00b6 Unfortunately, the free tier for CI's have a memory cap and some tests will cause the CI to experience an out of memory error. In order to mitigate this we have introduced the concept of short tests . If your PR causes an out of memory error please separate the tests into two groups like below and make sure to label it large : var stringTest = [] string { \"This causes no leaks\" } var largeStringTest = [] string { \"Whoa this test is so big it causes an out of memory issue\" } func TestStringTest ( t * testing . T ) { ... } func TestLargeStringTest ( t * testing . T ) { if testing . Short () { t . Skip ( \" \\033 [33mSkipping memory intesive test for <TEST NAME> in short mode \\033 [0m\" ) } else { ... } } Contributor Responsibilities \u00b6 We consider two types of contributions to our repo and categorize them as follows: Part-Time Contributors \u00b6 Anyone can become a part-time contributor and help out on gossamer. Contributions can be made in the following ways: Engaging in Discord conversations, asking questions on how to contribute to the project Opening up Github issues to contribute ideas on how the code can be improved Opening up PRs referencing any open issue in the repo. PRs should include: Detailed context of what would be required for merge Tests that are consistent with how other tests are written in our implementation Proper labels, milestones, and projects (see other closed PRs for reference) Follow up on open PRs Have an estimated timeframe to completion and let the core contributors know if a PR will take longer than expected We do not expect all part-time contributors to be experts on all the latest Polkadot documentation, but all contributors should at least be familiarized with the fundamentals of the Polkadot Runtime Specification . Core Contributors \u00b6 Core contributors are currently comprised of members of the ChainSafe Systems team. Core devs have all of the responsibilities of part-time contributors plus the majority of the following: Participate in our software development process (standups, sprint planning, retrospectives, etc) Stay up to date on the latest Polkadot research and updates Commit high quality code on core functionality Monitor github issues and PR\u2019s to make sure owner, labels, descriptions are correct Formulate independent ideas, suggest new work to do, point out improvements to existing approaches Participate in code review, ensure code quality is excellent, and ensure high code coverage","title":"Overview"},{"location":"contributing/#contribution-guidelines","text":"Thank you for your interest in our implementation of the Polkadot Runtime Environment Implementation! We're excited to get to know you and work with you on gossamer. We've put together these guidelines to help you figure out how you can help us. At any point in this process feel free to reach out on Discord with any questions or to say Hello :)","title":"Contribution Guidelines"},{"location":"contributing/#getting-started","text":"Generally, it is important to have a basic understanding of Polkadot and the Polkadot Runtime Environment. Having a stronger understanding will allow you to make more significant contributions. We've put together a list of resources that can help you develop this fundamental knowledge. The Web3 Foundation has a Polkadot Wiki that would help both part-time and core contributors to the project in order to get up to speed. Our wiki also has some helpful resources. The Polkadot Runtime Specification serves as our primary specification, however it is currently in its draft status so things may be subject to change. One important thing distinction is that we are building the Polkadot Runtime Environment, not Polkadot itself. Given that, although a deep understanding of Polkadot is helpful, it's not critical to contribute to gossamer. To help understand how the Runtime Environment relates to Polkadot, check out this talk that one of our team members gave at DotCon.","title":"Getting Started"},{"location":"contributing/#contribution-steps","text":"1. Fork the gossamer repo. 2. Create a local clone of gossamer. go get - u github . com / ChainSafe / gossamer cd $ GOPATH / src / github . com / ChainSafe / gossamer git init You may encounter a package github.com/ChainSafe/gossamer: no Go files in ... message when doing go get . This is not an error, since there are no go files in the project root. 3. Link your local clone to the fork on your Github repo. $ git remote add your-gossamer-repo https://github.com/<your_github_user_name>/gossamer.git 4. Link your local clone to the ChainSafe Systems repo so that you can easily fetch future changes to the ChainSafe Systems repo. $ git remote add gossamer https://github.com/ChainSafe/gossamer.git $ git remote -v ( you should see myrepo and gossamer in the list of remotes ) 5. Find something to work on. To start, check out our open issues. We recommend starting with an issue labeled Good First Issue . Leave a comment to let us know that you would like to work on it. Another option is to improve gossamer where you see fit based on your evaluation of our code. In order to best facilitate collaboration, please create an issue before you start working on it. 6. Make improvements to the code. Each time you work on the code be sure that you are working on the branch that you have created as opposed to your local copy of the gossamer repo. Keeping your changes segregated in this branch will make it easier to merge your changes into the repo later. $ git checkout feature-in-progress-branch 7. Test your changes. Changes that only affect a single file can be tested with $ go test <file_you_are_working_on> 8. Lint your changes. Before opening a pull request be sure to run the linter $ make lint 9. Create a pull request. Navigate your browser to https://github.com/ChainSafe/gossamer and click on the new pull request button. In the \u201cbase\u201d box on the left, change the branch to \u201c base development \u201d, the branch that you want your changes to be applied to. In the \u201ccompare\u201d box on the right, select feature-in-progress-branch, the branch containing the changes you want to apply. You will then be asked to answer a few questions about your pull request. After you complete the questionnaire, the pull request will appear in the list of pull requests at https://github.com/ChainSafe/gossamer/pulls .","title":"Contribution Steps"},{"location":"contributing/#note-on-memory-intensive-tests","text":"Unfortunately, the free tier for CI's have a memory cap and some tests will cause the CI to experience an out of memory error. In order to mitigate this we have introduced the concept of short tests . If your PR causes an out of memory error please separate the tests into two groups like below and make sure to label it large : var stringTest = [] string { \"This causes no leaks\" } var largeStringTest = [] string { \"Whoa this test is so big it causes an out of memory issue\" } func TestStringTest ( t * testing . T ) { ... } func TestLargeStringTest ( t * testing . T ) { if testing . Short () { t . Skip ( \" \\033 [33mSkipping memory intesive test for <TEST NAME> in short mode \\033 [0m\" ) } else { ... } }","title":"Note on memory intensive tests"},{"location":"contributing/#contributor-responsibilities","text":"We consider two types of contributions to our repo and categorize them as follows:","title":"Contributor Responsibilities"},{"location":"contributing/#part-time-contributors","text":"Anyone can become a part-time contributor and help out on gossamer. Contributions can be made in the following ways: Engaging in Discord conversations, asking questions on how to contribute to the project Opening up Github issues to contribute ideas on how the code can be improved Opening up PRs referencing any open issue in the repo. PRs should include: Detailed context of what would be required for merge Tests that are consistent with how other tests are written in our implementation Proper labels, milestones, and projects (see other closed PRs for reference) Follow up on open PRs Have an estimated timeframe to completion and let the core contributors know if a PR will take longer than expected We do not expect all part-time contributors to be experts on all the latest Polkadot documentation, but all contributors should at least be familiarized with the fundamentals of the Polkadot Runtime Specification .","title":"Part-Time Contributors"},{"location":"contributing/#core-contributors","text":"Core contributors are currently comprised of members of the ChainSafe Systems team. Core devs have all of the responsibilities of part-time contributors plus the majority of the following: Participate in our software development process (standups, sprint planning, retrospectives, etc) Stay up to date on the latest Polkadot research and updates Commit high quality code on core functionality Monitor github issues and PR\u2019s to make sure owner, labels, descriptions are correct Formulate independent ideas, suggest new work to do, point out improvements to existing approaches Participate in code review, ensure code quality is excellent, and ensure high code coverage","title":"Core Contributors"},{"location":"advanced/scale-examples/","text":"A byte array A is defined as a set of bytes (b1,...,bn) st. n < 2^536 . Let LS(x, n) be the least significant n bits of x We encode a mode as the least significant two bits of the first byte of each encoding. We use | to mean append. LE means little endian format n < 2^6; mode = 0 \u00b6 Enc(A) := l_1 | b_1 |...| b_n when n < 2^6 l_1 is the encoding of n . Since n < 2^6 we know n is at most 6 bits. We take these 6 bits and append 00 to indicate the 'mode' we are using. eg. n = 0x4 = 00000100 => LS(n, 6) = 000100 => Enc(A) := 000100| 00 | b_1 | ... | b_4 (ie. LS(n,6) | mode | bytes) 2^6 <= n < 2^14; mode = 1 \u00b6 Enc(A) := i_1 | i_2 | b_1 |...| b_n when 2^6 <= n < 2^14 i_1,i_2 are the encoding of n . Since 2^6 <= n < 2^14 we know n is between 7 and 14 bits. We truncate n to 14 bits (removing leading zeros or padding to 14 bits) and append 01 to indicate the 'mode'. eg. n = 0x1000 = 00010000,00000000 => LS(n, 14) = 010000,00000000 => 01000000,00000001 # Append mode bits, will store in LE in next step => Enc(A) := 00000001 | 01000000 | b_1 | ... | b_4096 (ie. LS(n,14) | mode | bytes) 2^14 <= n < 2^30; mode = 2 \u00b6 Enc(A) := i_1 | i_2 | i_3 | i_4 | b_1 |...| b_n when 2^14 <= n < 2^30 This is the same as the previous case, but now n occupies 30 bits and the mode is 2 . eg. n = 0x240FF80 = 00000010,01000000,11111111,10000000 => LS(n, 30) = 000010,01000000,11111111,10000000 => 00001001,00000011,11111110,00000010 # Append mode bits, will store in LE in next step => Enc(A) := 00000010 | 11111110 | 00000011 | 00001001 | b_1 | ... | b_37814144 (ie. LS(n,30) | mode | bytes) 2^30 <= n < 2^536 \u00b6 Enc(A) := k_1 | k_2 | k_3 | k_4 | k_5 | b_1 |...| b_n when 2^30 <= n < 2^536 In this case we define m to be the number of bytes used to store n . We then assign k_1 := m - 4 to indicate how many bytes to read for the size of n . eg. n = 0x100000000 = 00000001 | 0...0 | 0...0 | 0...0 | 0...0 => m = 5 => k_1 = m - 4 = 1 => 000001 | 11 | 0...0 | 0...0 | 0...0 | 0...0 | b_1 | ... | b_4294967296 (ie. m - 4 | mode | n | bytes)","title":"SCALE Examples"},{"location":"advanced/scale-examples/#n-26-mode-0","text":"Enc(A) := l_1 | b_1 |...| b_n when n < 2^6 l_1 is the encoding of n . Since n < 2^6 we know n is at most 6 bits. We take these 6 bits and append 00 to indicate the 'mode' we are using. eg. n = 0x4 = 00000100 => LS(n, 6) = 000100 => Enc(A) := 000100| 00 | b_1 | ... | b_4 (ie. LS(n,6) | mode | bytes)","title":"n &lt; 2^6; mode = 0"},{"location":"advanced/scale-examples/#26-n-214-mode-1","text":"Enc(A) := i_1 | i_2 | b_1 |...| b_n when 2^6 <= n < 2^14 i_1,i_2 are the encoding of n . Since 2^6 <= n < 2^14 we know n is between 7 and 14 bits. We truncate n to 14 bits (removing leading zeros or padding to 14 bits) and append 01 to indicate the 'mode'. eg. n = 0x1000 = 00010000,00000000 => LS(n, 14) = 010000,00000000 => 01000000,00000001 # Append mode bits, will store in LE in next step => Enc(A) := 00000001 | 01000000 | b_1 | ... | b_4096 (ie. LS(n,14) | mode | bytes)","title":"2^6 &lt;= n &lt; 2^14; mode = 1"},{"location":"advanced/scale-examples/#214-n-230-mode-2","text":"Enc(A) := i_1 | i_2 | i_3 | i_4 | b_1 |...| b_n when 2^14 <= n < 2^30 This is the same as the previous case, but now n occupies 30 bits and the mode is 2 . eg. n = 0x240FF80 = 00000010,01000000,11111111,10000000 => LS(n, 30) = 000010,01000000,11111111,10000000 => 00001001,00000011,11111110,00000010 # Append mode bits, will store in LE in next step => Enc(A) := 00000010 | 11111110 | 00000011 | 00001001 | b_1 | ... | b_37814144 (ie. LS(n,30) | mode | bytes)","title":"2^14 &lt;= n &lt; 2^30; mode = 2"},{"location":"advanced/scale-examples/#230-n-2536","text":"Enc(A) := k_1 | k_2 | k_3 | k_4 | k_5 | b_1 |...| b_n when 2^30 <= n < 2^536 In this case we define m to be the number of bytes used to store n . We then assign k_1 := m - 4 to indicate how many bytes to read for the size of n . eg. n = 0x100000000 = 00000001 | 0...0 | 0...0 | 0...0 | 0...0 => m = 5 => k_1 = m - 4 = 1 => 000001 | 11 | 0...0 | 0...0 | 0...0 | 0...0 | b_1 | ... | b_4294967296 (ie. m - 4 | mode | n | bytes)","title":"2^30 &lt;= n &lt; 2^536"},{"location":"getting-started/installation/","text":"Get Started \u00b6 Prerequisites \u00b6 Install Go version >=1.18 Installation \u00b6 Get the ChainSafe/gossamer repository: git clone git @github . com : ChainSafe / gossamer cd gossamer Run the following command to build the Gossamer binary: make gossamer Run Development Node \u00b6 To initialise a development node: ./bin/gossamer --chain dev init To start the development node: ./bin/gossamer --chain dev The development node is configured to produce a block every slot and to finalise a block every round (as there is only one authority, alice .) Run Gossamer Node \u00b6 The gossamer node runs by default as an authority with 9 authorites set at genesis. The built-in keys, corresponding to the authorities, that are available for the node are alice , bob , charlie , dave , eve , ferdie , george , and ian . To initialise a gossamer node: ./bin/gossamer --chain gssmr init To start the gossamer node: ./bin/gossamer --chain gssmr --key alice Note: If you only run one gossamer node, the node will not build blocks every slot or finalize blocks; it will appear that the node is doing nothing, but it is actually waiting for a slot to build a block. This is because there are 9 authorities set, so at least 6 of the authorities should be run for a functional network. If you wish to reduce the number of authorities, you can modify the genesis file in chain/gssmr/genesis-spec.json . If you wish to run the default node as a non-authority, you can specify roles=1 : ./bin/gossamer --chain gssmr --roles 1 Run Kusama Node \u00b6 To run a Kusama node, first initialise the node: ./bin/gossamer --chain kusama init Then run the node selecting the Kusama chain: ./bin/gossamer --chain kusama The node may not appear to do anything for the first minute or so (it's bootstrapping to the network.) If you wish to see what is it doing in this time, you can turn on debug logs in chain/kusama/config.toml : [log] network = \"debug\" After it's finished bootstrapping, the node should begin to sync. Run Polkadot Node \u00b6 Initialise polkadot node: ./bin/gossamer --chain polkadot init Start polkadot node: ./bin/gossamer --chain polkadot Run Gossamer Node with Docker \u00b6 Gossamer can also be installed on GNU/Linux, MacOS systems with Docker. Dependencies \u00b6 Install the latest release of Docker Ensure you are running the most recent version of Docker by issuing the command: docker -v Pull the latest Gossamer images from DockerHub Registry: docker pull chainsafe/gossamer:latest The above command will install all required dependencies. Next, we need override the default entrypoint so we can run the node as an authority node docker run -it --entrypoint /bin/bash chainsafe/gossamer:latest The built-in authorities are alice , bob , charlie , dave , eve , ferdie , george , and ian . To start the node as an authority, provide it with a built-in key: ./bin/gossamer --chain gssmr --key alice","title":"Installation"},{"location":"getting-started/installation/#get-started","text":"","title":"Get Started"},{"location":"getting-started/installation/#prerequisites","text":"Install Go version >=1.18","title":"Prerequisites"},{"location":"getting-started/installation/#installation","text":"Get the ChainSafe/gossamer repository: git clone git @github . com : ChainSafe / gossamer cd gossamer Run the following command to build the Gossamer binary: make gossamer","title":"Installation"},{"location":"getting-started/installation/#run-development-node","text":"To initialise a development node: ./bin/gossamer --chain dev init To start the development node: ./bin/gossamer --chain dev The development node is configured to produce a block every slot and to finalise a block every round (as there is only one authority, alice .)","title":"Run Development Node"},{"location":"getting-started/installation/#run-gossamer-node","text":"The gossamer node runs by default as an authority with 9 authorites set at genesis. The built-in keys, corresponding to the authorities, that are available for the node are alice , bob , charlie , dave , eve , ferdie , george , and ian . To initialise a gossamer node: ./bin/gossamer --chain gssmr init To start the gossamer node: ./bin/gossamer --chain gssmr --key alice Note: If you only run one gossamer node, the node will not build blocks every slot or finalize blocks; it will appear that the node is doing nothing, but it is actually waiting for a slot to build a block. This is because there are 9 authorities set, so at least 6 of the authorities should be run for a functional network. If you wish to reduce the number of authorities, you can modify the genesis file in chain/gssmr/genesis-spec.json . If you wish to run the default node as a non-authority, you can specify roles=1 : ./bin/gossamer --chain gssmr --roles 1","title":"Run Gossamer Node"},{"location":"getting-started/installation/#run-kusama-node","text":"To run a Kusama node, first initialise the node: ./bin/gossamer --chain kusama init Then run the node selecting the Kusama chain: ./bin/gossamer --chain kusama The node may not appear to do anything for the first minute or so (it's bootstrapping to the network.) If you wish to see what is it doing in this time, you can turn on debug logs in chain/kusama/config.toml : [log] network = \"debug\" After it's finished bootstrapping, the node should begin to sync.","title":"Run Kusama Node"},{"location":"getting-started/installation/#run-polkadot-node","text":"Initialise polkadot node: ./bin/gossamer --chain polkadot init Start polkadot node: ./bin/gossamer --chain polkadot","title":"Run Polkadot Node"},{"location":"getting-started/installation/#run-gossamer-node-with-docker","text":"Gossamer can also be installed on GNU/Linux, MacOS systems with Docker.","title":"Run Gossamer Node with Docker"},{"location":"getting-started/installation/#dependencies","text":"Install the latest release of Docker Ensure you are running the most recent version of Docker by issuing the command: docker -v Pull the latest Gossamer images from DockerHub Registry: docker pull chainsafe/gossamer:latest The above command will install all required dependencies. Next, we need override the default entrypoint so we can run the node as an authority node docker run -it --entrypoint /bin/bash chainsafe/gossamer:latest The built-in authorities are alice , bob , charlie , dave , eve , ferdie , george , and ian . To start the node as an authority, provide it with a built-in key: ./bin/gossamer --chain gssmr --key alice","title":"Dependencies"},{"location":"getting-started/overview/host-architecture/","text":"Nodes \u00b6 Gossamer includes a base node implementation called the host node that implements a shared base protocol for all blockchain protocols within the Polkadot ecosystem. The host node is used as the foundation for all official nodes within Gossamer and all custom nodes built with Gossamer. Host Node \u00b6 The host node is the base node implementation. As the base node implementation, the host node is not complete without a configuration file, genesis file, compiled runtime, and runtime imports. Official Nodes \u00b6 The gssmr node is an official node implementation for the Gossamer Testnet - a configuration file, genesis file, compiled runtime, and runtime imports used with the host node . The kusama node is an official node implementation for the Kusama Network - a configuration file, genesis file, compiled runtime, and runtime imports used with the host node . The polkadot node is an official node implementation for the Polkadot Network - a configuration file, genesis file, compiled runtime, and runtime imports used with the host node . Node Services \u00b6 The node services are the main components of the host node : Core Service Network Service RPC Service State Service Each node service adheres to a common interface: type Service interface { Start () error Stop () error } All goroutines within node services should start inside Start All node services can be terminated without consequences by calling Stop All node services whose Start method has not been called can be discarded without consequences Core Service \u00b6 The core service is responsible for block production and finalisation (consensus) and processing messages received from the network service ; it initialises BABE sessions and GRANDPA rounds and validates blocks and transactions before committing them to the state service . only the core service writes to block state only the core service writes to storage state Network Service \u00b6 The network service is responsible for coordinating network host and peer interactions. It manages peer connections, receives and parses messages from connected peers and handles each message based on its type. If the message is a non-status message and we have confirmed the status of the connected peer, the message is sent to the core service to be processed. the network service only reads from block state only the network service writes to network state Host Submodule \u00b6 The host submodule is a wrapper for the libp2p host. This is used to abstract away the details of libp2p and to provide a simple reusable interface for the network host. type host struct { ctx context . Context h libp2phost . Host dht * kaddht . IpfsDHT bootnodes [] peer . AddrInfo protocolID protocol . ID } RPC Service \u00b6 The rpc service is an implementation of the JSON-RPC PSP . State Service \u00b6 The state service is the source of truth for all chain and node state. Block production \u00b6 A block is broken down into two sections, the header & the body . The first step is to get information about the parent block, for new blocks, this would be the head of the chain. The parent hash and state root is added to the block header (point 1 & 2) We then need to process the extrinsics (point 3) , extrinsics is used to describe any additional information to include in the block that isn't explicitly required to produce a block, such as signed transactions from accounts, or additional information added by the block author, like a timestamp . Once processed, we get whats called an extrinsic root (point 4) , this is used to verify the extrinsics when publishing later on. Finally, once all the contents of the block are in place, we then create the digest (point 5) , this is used to verify the blocks contents. Information regarding the authoring of the block is stored in the Babe header , this allows verification of the block producer, the block, and the authority of the producer. Finally, the last item of the digest, much like transactions, is a signature known as a Seal , this is a signature of the header to allow immediate verification of the integrity of a block.","title":"Host Architecture"},{"location":"getting-started/overview/host-architecture/#nodes","text":"Gossamer includes a base node implementation called the host node that implements a shared base protocol for all blockchain protocols within the Polkadot ecosystem. The host node is used as the foundation for all official nodes within Gossamer and all custom nodes built with Gossamer.","title":"Nodes"},{"location":"getting-started/overview/host-architecture/#host-node","text":"The host node is the base node implementation. As the base node implementation, the host node is not complete without a configuration file, genesis file, compiled runtime, and runtime imports.","title":"Host Node"},{"location":"getting-started/overview/host-architecture/#official-nodes","text":"The gssmr node is an official node implementation for the Gossamer Testnet - a configuration file, genesis file, compiled runtime, and runtime imports used with the host node . The kusama node is an official node implementation for the Kusama Network - a configuration file, genesis file, compiled runtime, and runtime imports used with the host node . The polkadot node is an official node implementation for the Polkadot Network - a configuration file, genesis file, compiled runtime, and runtime imports used with the host node .","title":"Official Nodes"},{"location":"getting-started/overview/host-architecture/#node-services","text":"The node services are the main components of the host node : Core Service Network Service RPC Service State Service Each node service adheres to a common interface: type Service interface { Start () error Stop () error } All goroutines within node services should start inside Start All node services can be terminated without consequences by calling Stop All node services whose Start method has not been called can be discarded without consequences","title":"Node Services"},{"location":"getting-started/overview/host-architecture/#core-service","text":"The core service is responsible for block production and finalisation (consensus) and processing messages received from the network service ; it initialises BABE sessions and GRANDPA rounds and validates blocks and transactions before committing them to the state service . only the core service writes to block state only the core service writes to storage state","title":"Core Service"},{"location":"getting-started/overview/host-architecture/#network-service","text":"The network service is responsible for coordinating network host and peer interactions. It manages peer connections, receives and parses messages from connected peers and handles each message based on its type. If the message is a non-status message and we have confirmed the status of the connected peer, the message is sent to the core service to be processed. the network service only reads from block state only the network service writes to network state","title":"Network Service"},{"location":"getting-started/overview/host-architecture/#host-submodule","text":"The host submodule is a wrapper for the libp2p host. This is used to abstract away the details of libp2p and to provide a simple reusable interface for the network host. type host struct { ctx context . Context h libp2phost . Host dht * kaddht . IpfsDHT bootnodes [] peer . AddrInfo protocolID protocol . ID }","title":"Host Submodule"},{"location":"getting-started/overview/host-architecture/#rpc-service","text":"The rpc service is an implementation of the JSON-RPC PSP .","title":"RPC Service"},{"location":"getting-started/overview/host-architecture/#state-service","text":"The state service is the source of truth for all chain and node state.","title":"State Service"},{"location":"getting-started/overview/host-architecture/#block-production","text":"A block is broken down into two sections, the header & the body . The first step is to get information about the parent block, for new blocks, this would be the head of the chain. The parent hash and state root is added to the block header (point 1 & 2) We then need to process the extrinsics (point 3) , extrinsics is used to describe any additional information to include in the block that isn't explicitly required to produce a block, such as signed transactions from accounts, or additional information added by the block author, like a timestamp . Once processed, we get whats called an extrinsic root (point 4) , this is used to verify the extrinsics when publishing later on. Finally, once all the contents of the block are in place, we then create the digest (point 5) , this is used to verify the blocks contents. Information regarding the authoring of the block is stored in the Babe header , this allows verification of the block producer, the block, and the authority of the producer. Finally, the last item of the digest, much like transactions, is a signature known as a Seal , this is a signature of the header to allow immediate verification of the integrity of a block.","title":"Block production"},{"location":"getting-started/overview/package-library/","text":"Overview \u00b6 Gossamer is a modular blockchain framework ; it was designed with a package structure that makes it possible to reuse Gossamer packages to build and run custom nodes and node services. This document provides an overview of the packages that make up the Gossamer framework - more detailed information about each package can be found at pkg.go.dev/ChainSafe/gossamer . Gossamer packages can be categorized into four package types : cmd packages cmd/... - command-line packages for running nodes and other services dot packages dot/... - the dot node package and host node service packages lib packages lib/... - modular packages for building nodes and other services test packages tests/... - test packages for integration tests cmd packages \u00b6 cmd/gossamer \u00b6 The gossamer package is used to run nodes built with Gossamer. dot packages \u00b6 dot \u00b6 The dot package contains packages that implement the Polkadot Host spec. The dot package implements the Host Node ; it is the base node implementation for all Official Nodes and Custom Services built with Gossamer. dot/core \u00b6 The core package implements the Core Service - responsible for block production and block finalisation (consensus) and processing messages received from the Network Service . dot/network \u00b6 The network package implements the Network Service - responsible for coordinating network host and peer interactions. It manages peer connections, receives and parses messages from connected peers and handles each message based on its type. dot/state \u00b6 The state package implements the State Service - the source of truth for all chain and node state that is made accessible to all node services. dot/sync \u00b6 The sync package implements handling of blocks received from the network layer. dot/rpc \u00b6 The rpc package implements the RPC Service - an HTTP server that handles state interactions. dot/types \u00b6 The types package implements types defined within the Polkadot Host specification. lib packages \u00b6 lib/babe \u00b6 the babe package implements the BABE block production algorithm. lib/blocktree \u00b6 the blocktree package implements the blocktree, a data structure which tracks the chain and all its non-finalised forks. lib/common \u00b6 the common package defines common types and functions. lib/crypto \u00b6 the crypto package contains the key types used by the node (sr25519, ed25519, secp256k1). lib/grandpa \u00b6 the grandpa package implements the GRANDPA finality gadget. lib/keystore \u00b6 the keystore package manages the keystore and includes test keyrings. lib/runtime \u00b6 the runtime package contains various wasm interpreters used to interpret the runtime. It currently contains life and wasmer ; however, wasmer is the only interpreter that is fully supported at the moment. In the future, all interpreters will be fully supported. lib/services \u00b6 the services package implements a common interface for node services. lib/transaction \u00b6 the transaction package is contains transaction types and the transaction queue data structure. lib/trie \u00b6 the trie package implements a modified merkle-patricia trie. lib/utils \u00b6 the utils package is used to manage node and test directories. test packages \u00b6 tests/polkadotjs_test \u00b6 the polkadotjs_test section is a node.js implementation to test interaction with Gossamer's RPC. tests/rpc \u00b6 the rpc test collection comprises tests to cover the RPC's various endpoints and return data. tests/stress \u00b6 the stress test collection comprises tests to simulate the node running under various high stress scenarios tests/sync \u00b6 the sync test collection comprises tests to verify the integrity of syncing operations and features tests/utils \u00b6 the utils test collection comprises tests to validate the function of various utilities throughout the Gossamer stack","title":"Package Library"},{"location":"getting-started/overview/package-library/#overview","text":"Gossamer is a modular blockchain framework ; it was designed with a package structure that makes it possible to reuse Gossamer packages to build and run custom nodes and node services. This document provides an overview of the packages that make up the Gossamer framework - more detailed information about each package can be found at pkg.go.dev/ChainSafe/gossamer . Gossamer packages can be categorized into four package types : cmd packages cmd/... - command-line packages for running nodes and other services dot packages dot/... - the dot node package and host node service packages lib packages lib/... - modular packages for building nodes and other services test packages tests/... - test packages for integration tests","title":"Overview"},{"location":"getting-started/overview/package-library/#cmd-packages","text":"","title":"cmd packages"},{"location":"getting-started/overview/package-library/#cmdgossamer","text":"The gossamer package is used to run nodes built with Gossamer.","title":"cmd/gossamer"},{"location":"getting-started/overview/package-library/#dot-packages","text":"","title":"dot packages"},{"location":"getting-started/overview/package-library/#dot","text":"The dot package contains packages that implement the Polkadot Host spec. The dot package implements the Host Node ; it is the base node implementation for all Official Nodes and Custom Services built with Gossamer.","title":"dot"},{"location":"getting-started/overview/package-library/#dotcore","text":"The core package implements the Core Service - responsible for block production and block finalisation (consensus) and processing messages received from the Network Service .","title":"dot/core"},{"location":"getting-started/overview/package-library/#dotnetwork","text":"The network package implements the Network Service - responsible for coordinating network host and peer interactions. It manages peer connections, receives and parses messages from connected peers and handles each message based on its type.","title":"dot/network"},{"location":"getting-started/overview/package-library/#dotstate","text":"The state package implements the State Service - the source of truth for all chain and node state that is made accessible to all node services.","title":"dot/state"},{"location":"getting-started/overview/package-library/#dotsync","text":"The sync package implements handling of blocks received from the network layer.","title":"dot/sync"},{"location":"getting-started/overview/package-library/#dotrpc","text":"The rpc package implements the RPC Service - an HTTP server that handles state interactions.","title":"dot/rpc"},{"location":"getting-started/overview/package-library/#dottypes","text":"The types package implements types defined within the Polkadot Host specification.","title":"dot/types"},{"location":"getting-started/overview/package-library/#lib-packages","text":"","title":"lib packages"},{"location":"getting-started/overview/package-library/#libbabe","text":"the babe package implements the BABE block production algorithm.","title":"lib/babe"},{"location":"getting-started/overview/package-library/#libblocktree","text":"the blocktree package implements the blocktree, a data structure which tracks the chain and all its non-finalised forks.","title":"lib/blocktree"},{"location":"getting-started/overview/package-library/#libcommon","text":"the common package defines common types and functions.","title":"lib/common"},{"location":"getting-started/overview/package-library/#libcrypto","text":"the crypto package contains the key types used by the node (sr25519, ed25519, secp256k1).","title":"lib/crypto"},{"location":"getting-started/overview/package-library/#libgrandpa","text":"the grandpa package implements the GRANDPA finality gadget.","title":"lib/grandpa"},{"location":"getting-started/overview/package-library/#libkeystore","text":"the keystore package manages the keystore and includes test keyrings.","title":"lib/keystore"},{"location":"getting-started/overview/package-library/#libruntime","text":"the runtime package contains various wasm interpreters used to interpret the runtime. It currently contains life and wasmer ; however, wasmer is the only interpreter that is fully supported at the moment. In the future, all interpreters will be fully supported.","title":"lib/runtime"},{"location":"getting-started/overview/package-library/#libservices","text":"the services package implements a common interface for node services.","title":"lib/services"},{"location":"getting-started/overview/package-library/#libtransaction","text":"the transaction package is contains transaction types and the transaction queue data structure.","title":"lib/transaction"},{"location":"getting-started/overview/package-library/#libtrie","text":"the trie package implements a modified merkle-patricia trie.","title":"lib/trie"},{"location":"getting-started/overview/package-library/#libutils","text":"the utils package is used to manage node and test directories.","title":"lib/utils"},{"location":"getting-started/overview/package-library/#test-packages","text":"","title":"test packages"},{"location":"getting-started/overview/package-library/#testspolkadotjs_test","text":"the polkadotjs_test section is a node.js implementation to test interaction with Gossamer's RPC.","title":"tests/polkadotjs_test"},{"location":"getting-started/overview/package-library/#testsrpc","text":"the rpc test collection comprises tests to cover the RPC's various endpoints and return data.","title":"tests/rpc"},{"location":"getting-started/overview/package-library/#testsstress","text":"the stress test collection comprises tests to simulate the node running under various high stress scenarios","title":"tests/stress"},{"location":"getting-started/overview/package-library/#testssync","text":"the sync test collection comprises tests to verify the integrity of syncing operations and features","title":"tests/sync"},{"location":"getting-started/overview/package-library/#testsutils","text":"the utils test collection comprises tests to validate the function of various utilities throughout the Gossamer stack","title":"tests/utils"},{"location":"getting-started/resources/developer-resources/","text":"Specification \u00b6 Polkadot Host Specification Cryptography \u00b6 blake2s used for hashing ed25519 (signing) ed25519 (curve) Networking \u00b6 W3F networking research libp2p Specs Kademlia (DHT) White Paper Kademlia Wiki Page WASM \u00b6 WASM Specification Wasm on the Blockchain: The Lesser Evil [blog post] Polkadot \u00b6 Polkadot Wiki Polkadot Consensus Wiki Polkadot Runtime Environment Specification (Section 8.2) Rust Docs: finality_grandpa paritytech/finality_grandpa The State of Crypto Interoperability Explained in Pictures Parachains \u00b6 The Parachain (Blog Post) Parachains on Polkadot Wiki Parathreads (Blog Post) Parathreads on Polkadot Wiki The Path of a Parachain Block The Path of a Parachain Block (Video) Block production & consensus \u00b6 BABE Specification GRANDPA Specification Polkadot Consensus Part 1: Introduction Polkadot Consensus Part 2: GRANDPA Polkadot Consensus Part 3: BABE Polkadot Consensus Part 4: Security Staking Diagram Substrate \u00b6 Official Substrate Documentation","title":"Developer Resources"},{"location":"getting-started/resources/developer-resources/#specification","text":"Polkadot Host Specification","title":"Specification"},{"location":"getting-started/resources/developer-resources/#cryptography","text":"blake2s used for hashing ed25519 (signing) ed25519 (curve)","title":"Cryptography"},{"location":"getting-started/resources/developer-resources/#networking","text":"W3F networking research libp2p Specs Kademlia (DHT) White Paper Kademlia Wiki Page","title":"Networking"},{"location":"getting-started/resources/developer-resources/#wasm","text":"WASM Specification Wasm on the Blockchain: The Lesser Evil [blog post]","title":"WASM"},{"location":"getting-started/resources/developer-resources/#polkadot","text":"Polkadot Wiki Polkadot Consensus Wiki Polkadot Runtime Environment Specification (Section 8.2) Rust Docs: finality_grandpa paritytech/finality_grandpa The State of Crypto Interoperability Explained in Pictures","title":"Polkadot"},{"location":"getting-started/resources/developer-resources/#parachains","text":"The Parachain (Blog Post) Parachains on Polkadot Wiki Parathreads (Blog Post) Parathreads on Polkadot Wiki The Path of a Parachain Block The Path of a Parachain Block (Video)","title":"Parachains"},{"location":"getting-started/resources/developer-resources/#block-production-consensus","text":"BABE Specification GRANDPA Specification Polkadot Consensus Part 1: Introduction Polkadot Consensus Part 2: GRANDPA Polkadot Consensus Part 3: BABE Polkadot Consensus Part 4: Security Staking Diagram","title":"Block production &amp; consensus"},{"location":"getting-started/resources/developer-resources/#substrate","text":"Official Substrate Documentation","title":"Substrate"},{"location":"getting-started/resources/general-resources/","text":"Welcome \u00b6 Here you will find resources to help facilitate your learning about Polkadot , the Polkadot Host , and Gossamer . Don't worry if you are unfamiliar with these terms , the resources listed here assume no prior knowledge about them. That being said, it would be helpful to have a basic understanding of existing blockchains such as Bitcoin and Ethereum. Polkadot \u00b6 To start, it would be extremely beneficial to have an understanding of the Polkadot Network. For a high-level introduction to Polkadot, check out the lightpaper . To understand the motivation behind Polkadot's creation and what makes it unique, check out this great blog post A brief summary of everything Substrate and Polkadot . While reading, it would be helpful to note that Substrate and Gossamer are both implementations of the Polkadot Host. Additional Resources \u00b6 Docs \u00b6 Polkadot Wiki Polkadot Paper Articles \u00b6 How Polkadot tackles the biggest problems facing blockchain innovators - June 7th 2018 Block explorers \u00b6 Polkadot Explorer Polkascan - Polkadot block explorer Polkadot Telemetry Service Polkadot Host \u00b6 [ Please Note: The \"Polkadot Host\" was formerly known as the \"Polkadot Runtime Environment\" ] The Polkadot Host plays two important roles within the Polkadot ecosystem. The Polkadot Host implements the fundamental components for a blockchain , ie networking and consensus. These components are not expected to change, and as such, they host part of the blockchain that is expected to change, the Runtime. For more details, check out Polkadot Host . The Polkadot Host is a blockchain development framework , similar to how React and Angular are web development frameworks, but rather than helping developers build web applications, implementations of the Polkadot Host help developers build blockchains. As mentioned above, both Substrate and Gossamer are implementations of the Polkadot Host. If you're interested in the nitty-gritty technical details, check out the Polkadot Host specification . Gossamer \u00b6 Gossamer is an implementation of the Polkadot Host in Go. To learn more about Gossamer, we recommend the following resources: To understand the vision behind Gossamer and how it fits into the Polkadot ecosystem, please read this blog post: \"The Future of Polkadot in Golang: Gossamer\" . For a more technical explanation, we recommend watching this video . Additional Resources \u00b6 Videos \u00b6 Web3 Builders: ChainSafe - GoLang Implementation of Polkadot Host Articles \u00b6 Gossamer Update: Introducing Gossamer - March 20th 2019 Gossamer Update: Merkle-Patricia Trie - June 5th 2019 Towards a Better Internet: Web3, Polkadot, and Gossamer - September 25th, 2019 Building the Future with Gossamer - October 23rd 2019 ChainSafe Releases Go-Schnorrkel - January 23rd 2020 The Future of Polkadot in Golang: Gossamer - February 24th 2020 Gossamer Update: August 2020 - August 25th 2020 Gossamer Update: September 2020 - October 6th 2020 Gossamer Update: November 2020 - November 27th 2020 Gossamer: Into the Polkadot-verse Pt.1 - February 26th 2021 Building parachains with go-cumulus - April 20th 2021 Substrate \u00b6 Docs \u00b6 Substrate Documentation Videos \u00b6 Gavin Wood on Substrate at Event Horizon 2018 Rob Habermeier presents Parity Substrate Articles \u00b6 What is Substrate? - July 9th 2018 A brief summary of everything Substrate and Polkadot - March 18th 2019 Web3 Foundation \u00b6 Docs \u00b6 Web3 Foundation's General Grants Program Articles \u00b6 Why Wy Need Web 3.0 - September 12th 2018","title":"General Resources"},{"location":"getting-started/resources/general-resources/#welcome","text":"Here you will find resources to help facilitate your learning about Polkadot , the Polkadot Host , and Gossamer . Don't worry if you are unfamiliar with these terms , the resources listed here assume no prior knowledge about them. That being said, it would be helpful to have a basic understanding of existing blockchains such as Bitcoin and Ethereum.","title":"Welcome"},{"location":"getting-started/resources/general-resources/#polkadot","text":"To start, it would be extremely beneficial to have an understanding of the Polkadot Network. For a high-level introduction to Polkadot, check out the lightpaper . To understand the motivation behind Polkadot's creation and what makes it unique, check out this great blog post A brief summary of everything Substrate and Polkadot . While reading, it would be helpful to note that Substrate and Gossamer are both implementations of the Polkadot Host.","title":"Polkadot"},{"location":"getting-started/resources/general-resources/#additional-resources","text":"","title":"Additional Resources"},{"location":"getting-started/resources/general-resources/#docs","text":"Polkadot Wiki Polkadot Paper","title":"Docs"},{"location":"getting-started/resources/general-resources/#articles","text":"How Polkadot tackles the biggest problems facing blockchain innovators - June 7th 2018","title":"Articles"},{"location":"getting-started/resources/general-resources/#block-explorers","text":"Polkadot Explorer Polkascan - Polkadot block explorer Polkadot Telemetry Service","title":"Block explorers"},{"location":"getting-started/resources/general-resources/#polkadot-host","text":"[ Please Note: The \"Polkadot Host\" was formerly known as the \"Polkadot Runtime Environment\" ] The Polkadot Host plays two important roles within the Polkadot ecosystem. The Polkadot Host implements the fundamental components for a blockchain , ie networking and consensus. These components are not expected to change, and as such, they host part of the blockchain that is expected to change, the Runtime. For more details, check out Polkadot Host . The Polkadot Host is a blockchain development framework , similar to how React and Angular are web development frameworks, but rather than helping developers build web applications, implementations of the Polkadot Host help developers build blockchains. As mentioned above, both Substrate and Gossamer are implementations of the Polkadot Host. If you're interested in the nitty-gritty technical details, check out the Polkadot Host specification .","title":"Polkadot Host"},{"location":"getting-started/resources/general-resources/#gossamer","text":"Gossamer is an implementation of the Polkadot Host in Go. To learn more about Gossamer, we recommend the following resources: To understand the vision behind Gossamer and how it fits into the Polkadot ecosystem, please read this blog post: \"The Future of Polkadot in Golang: Gossamer\" . For a more technical explanation, we recommend watching this video .","title":"Gossamer"},{"location":"getting-started/resources/general-resources/#additional-resources_1","text":"","title":"Additional Resources"},{"location":"getting-started/resources/general-resources/#videos","text":"Web3 Builders: ChainSafe - GoLang Implementation of Polkadot Host","title":"Videos"},{"location":"getting-started/resources/general-resources/#articles_1","text":"Gossamer Update: Introducing Gossamer - March 20th 2019 Gossamer Update: Merkle-Patricia Trie - June 5th 2019 Towards a Better Internet: Web3, Polkadot, and Gossamer - September 25th, 2019 Building the Future with Gossamer - October 23rd 2019 ChainSafe Releases Go-Schnorrkel - January 23rd 2020 The Future of Polkadot in Golang: Gossamer - February 24th 2020 Gossamer Update: August 2020 - August 25th 2020 Gossamer Update: September 2020 - October 6th 2020 Gossamer Update: November 2020 - November 27th 2020 Gossamer: Into the Polkadot-verse Pt.1 - February 26th 2021 Building parachains with go-cumulus - April 20th 2021","title":"Articles"},{"location":"getting-started/resources/general-resources/#substrate","text":"","title":"Substrate"},{"location":"getting-started/resources/general-resources/#docs_1","text":"Substrate Documentation","title":"Docs"},{"location":"getting-started/resources/general-resources/#videos_1","text":"Gavin Wood on Substrate at Event Horizon 2018 Rob Habermeier presents Parity Substrate","title":"Videos"},{"location":"getting-started/resources/general-resources/#articles_2","text":"What is Substrate? - July 9th 2018 A brief summary of everything Substrate and Polkadot - March 18th 2019","title":"Articles"},{"location":"getting-started/resources/general-resources/#web3-foundation","text":"","title":"Web3 Foundation"},{"location":"getting-started/resources/general-resources/#docs_2","text":"Web3 Foundation's General Grants Program","title":"Docs"},{"location":"getting-started/resources/general-resources/#articles_3","text":"Why Wy Need Web 3.0 - September 12th 2018","title":"Articles"},{"location":"integrate/connect-to-polkadot-js/","text":"Connecting to Polkadot.js \u00b6 To view your running Gossamer node with a UI, Polkadot has created a handy app , which you can use here: https://polkadot.js.org/apps/ If using Polkadot's hosted app, you will need to ensure your node has the --rpc-external , --ws & --ws-external flags, if you are running the app locally, just ensure the rpc & websocket servers are running ( --rpc && --ws ) For example: bin/gossamer --rpc --ws --wsport 8546 --rpcmods system,author,chain,state,account,rpc --key alice Connecting the app to your node \u00b6 You'll need to setup the polkadot.js/apps to use a custom endpoint to connect to your gossamer node. Open polkadot.js.org/apps . Once you've opened the app in your browser, you should see it connected to the Polkadot network: In the top left hand corner, click the logo to open the network selection modal: Next, at the bottom of this menu is a \"Development\" dropdown, click to open that Now you should see a text area with the label \"custom endpoint\", here you add your local node's websocket address, usually \"ws://127.0.0.1:8586\", click the Save icon on the right of the text box to save the endpoint. Finally, click the \"Switch\" button at the top of this modal: Congratulations, you've successfully connected to your Gossamer node!","title":"Connect to Polkadot.js"},{"location":"integrate/connect-to-polkadot-js/#connecting-to-polkadotjs","text":"To view your running Gossamer node with a UI, Polkadot has created a handy app , which you can use here: https://polkadot.js.org/apps/ If using Polkadot's hosted app, you will need to ensure your node has the --rpc-external , --ws & --ws-external flags, if you are running the app locally, just ensure the rpc & websocket servers are running ( --rpc && --ws ) For example: bin/gossamer --rpc --ws --wsport 8546 --rpcmods system,author,chain,state,account,rpc --key alice","title":"Connecting to Polkadot.js"},{"location":"integrate/connect-to-polkadot-js/#connecting-the-app-to-your-node","text":"You'll need to setup the polkadot.js/apps to use a custom endpoint to connect to your gossamer node. Open polkadot.js.org/apps . Once you've opened the app in your browser, you should see it connected to the Polkadot network: In the top left hand corner, click the logo to open the network selection modal: Next, at the bottom of this menu is a \"Development\" dropdown, click to open that Now you should see a text area with the label \"custom endpoint\", here you add your local node's websocket address, usually \"ws://127.0.0.1:8586\", click the Save icon on the right of the text box to save the endpoint. Finally, click the \"Switch\" button at the top of this modal: Congratulations, you've successfully connected to your Gossamer node!","title":"Connecting the app to your node"},{"location":"integrate/using-prometheus/","text":"Using Prometheus Locally \u00b6 To get started with Prometheus locally make sure you have installed Docker and Docker Compose . The docker-compose.yml file has, currently, the Prometheus to collect metrics, so to start that service you can execute (in the project root folder): docker-compose up (-d to disatach the terminal) or docker-compose up prometheus (-d to disatach the terminal) the above command will starts the Prometheus service on 0.0.0.0:9090 . Prometheus \u00b6 Actually the Prometheus service reads a file prometheus.yml placed in the root level project folder, this file contains the definitions that Prometheus needs to collect the metrics. Linux: In the job_name == gossamer the targets property should be [localhost:9876] To publish metrics from the node use the flag --publish-metrics ; i.e, ./bin/gossamer --chain {chain} --key {key} --publish-metrics . By default, the Prometheus server listens on localhost:9876 , which you can change with --metrics-address . To listen on all interfaces, you can use --metrics-address=\":9876\" .","title":"Using Prometheus"},{"location":"integrate/using-prometheus/#using-prometheus-locally","text":"To get started with Prometheus locally make sure you have installed Docker and Docker Compose . The docker-compose.yml file has, currently, the Prometheus to collect metrics, so to start that service you can execute (in the project root folder): docker-compose up (-d to disatach the terminal) or docker-compose up prometheus (-d to disatach the terminal) the above command will starts the Prometheus service on 0.0.0.0:9090 .","title":"Using Prometheus Locally"},{"location":"integrate/using-prometheus/#prometheus","text":"Actually the Prometheus service reads a file prometheus.yml placed in the root level project folder, this file contains the definitions that Prometheus needs to collect the metrics. Linux: In the job_name == gossamer the targets property should be [localhost:9876] To publish metrics from the node use the flag --publish-metrics ; i.e, ./bin/gossamer --chain {chain} --key {key} --publish-metrics . By default, the Prometheus server listens on localhost:9876 , which you can change with --metrics-address . To listen on all interfaces, you can use --metrics-address=\":9876\" .","title":"Prometheus"},{"location":"testing-and-debugging/debugging/","text":"Logger Commands \u00b6 The log command is used for setting the logging levels for the node. Config File \u00b6 The logging level can be set using config.toml file, default log level will be set to info [log] core = \"trace | debug | info | warn | error | crit\" sync = \"trace | debug | info | warn | error | crit\" network = \"trace | debug | info | warn | error | crit\" rpc = \"trace | debug | info | warn | error | crit\" state = \"trace | debug | info | warn | error | crit\" runtime = \"trace | debug | info | warn | error | crit\" babe = \"trace | debug | info | warn | error | crit\" grandpa = \"trace | debug | info | warn | error | crit\" Logging Global Flags \u00b6 --log value Supports levels crit (silent) to trce (trace) (default: \"info\") Running node with log level as DEBUG \u00b6 ./bin/gossamer --config chain/gssmr/config.toml --log debug","title":"Debugging"},{"location":"testing-and-debugging/debugging/#logger-commands","text":"The log command is used for setting the logging levels for the node.","title":"Logger Commands"},{"location":"testing-and-debugging/debugging/#config-file","text":"The logging level can be set using config.toml file, default log level will be set to info [log] core = \"trace | debug | info | warn | error | crit\" sync = \"trace | debug | info | warn | error | crit\" network = \"trace | debug | info | warn | error | crit\" rpc = \"trace | debug | info | warn | error | crit\" state = \"trace | debug | info | warn | error | crit\" runtime = \"trace | debug | info | warn | error | crit\" babe = \"trace | debug | info | warn | error | crit\" grandpa = \"trace | debug | info | warn | error | crit\"","title":"Config File"},{"location":"testing-and-debugging/debugging/#logging-global-flags","text":"--log value Supports levels crit (silent) to trce (trace) (default: \"info\")","title":"Logging Global Flags"},{"location":"testing-and-debugging/debugging/#running-node-with-log-level-as-debug","text":"./bin/gossamer --config chain/gssmr/config.toml --log debug","title":"Running node with log level as DEBUG"},{"location":"testing-and-debugging/pprof/","text":"Pprof \u00b6 There is a built-in pprof server to faciliate profiling the program. You can enable it with the flag --pprofserver or by modifying the TOML configuration file. Note it does not affect performance unless the server is queried. We assume Gossamer runs on localhost and the Pprof server is listening on the default 6060 port. You can configure the Pprof server listening address with the pprof TOML key listening-address or the flag --pprofaddress . You need to have Go installed to profile the program. Browser \u00b6 The easiest way to visualize profiling data is through your browser. For example, the following commands will show interactive results at http://localhost:8000 : # Check the heap go tool pprof -http = localhost:8000 http://localhost:6060/debug/pprof/heap # Check the CPU time spent for 10 seconds go tool pprof -http = localhost:8000 http://localhost:6060/debug/pprof/profile?seconds = 10 Compare heaps \u00b6 You can compare heaps with Go's pprof, this is especially useful to find memory leaks. Download the first heap profile wget -qO heap.1.out http://localhost:6060/debug/pprof/heap Download the second heap profile wget -qO heap.2.out http://localhost:6060/debug/pprof/heap Compare the second heap profile with the first one using go tool pprof -base ./heap.1.out heap.2.out More routes \u00b6 More routes are available in the HTTP pprof server. You can also list them at http://localhost:6060/debug/pprof/ . Notable ones are written below: Goroutine blocking profile \u00b6 The route /debug/pprof/block is available but requires to set the block profile rate, using either the toml value block-rate or the flag --pprofblockrate . Mutex contention profile \u00b6 The route /debug/pprof/mutex is available but requires to set the mutex profile rate, using either the toml value mutex-rate or the flag --pprofmutexrate . Other routes \u00b6 The other routes are listed below, if you need them: /debug/pprof/cmdline /debug/pprof/symbol /debug/pprof/trace /debug/pprof/goroutine /debug/pprof/threadcreate","title":"Pprof"},{"location":"testing-and-debugging/pprof/#pprof","text":"There is a built-in pprof server to faciliate profiling the program. You can enable it with the flag --pprofserver or by modifying the TOML configuration file. Note it does not affect performance unless the server is queried. We assume Gossamer runs on localhost and the Pprof server is listening on the default 6060 port. You can configure the Pprof server listening address with the pprof TOML key listening-address or the flag --pprofaddress . You need to have Go installed to profile the program.","title":"Pprof"},{"location":"testing-and-debugging/pprof/#browser","text":"The easiest way to visualize profiling data is through your browser. For example, the following commands will show interactive results at http://localhost:8000 : # Check the heap go tool pprof -http = localhost:8000 http://localhost:6060/debug/pprof/heap # Check the CPU time spent for 10 seconds go tool pprof -http = localhost:8000 http://localhost:6060/debug/pprof/profile?seconds = 10","title":"Browser"},{"location":"testing-and-debugging/pprof/#compare-heaps","text":"You can compare heaps with Go's pprof, this is especially useful to find memory leaks. Download the first heap profile wget -qO heap.1.out http://localhost:6060/debug/pprof/heap Download the second heap profile wget -qO heap.2.out http://localhost:6060/debug/pprof/heap Compare the second heap profile with the first one using go tool pprof -base ./heap.1.out heap.2.out","title":"Compare heaps"},{"location":"testing-and-debugging/pprof/#more-routes","text":"More routes are available in the HTTP pprof server. You can also list them at http://localhost:6060/debug/pprof/ . Notable ones are written below:","title":"More routes"},{"location":"testing-and-debugging/pprof/#goroutine-blocking-profile","text":"The route /debug/pprof/block is available but requires to set the block profile rate, using either the toml value block-rate or the flag --pprofblockrate .","title":"Goroutine blocking profile"},{"location":"testing-and-debugging/pprof/#mutex-contention-profile","text":"The route /debug/pprof/mutex is available but requires to set the mutex profile rate, using either the toml value mutex-rate or the flag --pprofmutexrate .","title":"Mutex contention profile"},{"location":"testing-and-debugging/pprof/#other-routes","text":"The other routes are listed below, if you need them: /debug/pprof/cmdline /debug/pprof/symbol /debug/pprof/trace /debug/pprof/goroutine /debug/pprof/threadcreate","title":"Other routes"},{"location":"testing-and-debugging/test-suite/","text":"Gossamer Test Suite \u00b6 To run Gossamer unit tests run the following command: make test The above command will run all tests on project files with a timeout set for 20 minutes, and generate a coverage report in root c.out . You can view the coverage report through HTML by running the below command after running the above unit tests, or by visiting our code coverage report here . go tool cover - html = c . out - o cover . html Proceed to open cover.html in your preferred browser. Gossamer Integration Tests \u00b6 Running Gossamer's integration tests with the below commands will build a Gossamer binary, install required dependencies, and then proceeds to run the provided set of tests. Integration tests can also be run within a docker container. To run Gossamer integration tests in stress mode run the following command: make it-stress To run Gossamer integration tests against GRANDPA in stress mode run the following command: make it-grandpa To run Gossamer RPC integration tests run the following command: make it-rpc To run Gossamer Sync integration tests run the following command: make it-sync To run Gossamer Polkadot.js integration tests run the following command: make it-polkadotjs","title":"Test Suite"},{"location":"testing-and-debugging/test-suite/#gossamer-test-suite","text":"To run Gossamer unit tests run the following command: make test The above command will run all tests on project files with a timeout set for 20 minutes, and generate a coverage report in root c.out . You can view the coverage report through HTML by running the below command after running the above unit tests, or by visiting our code coverage report here . go tool cover - html = c . out - o cover . html Proceed to open cover.html in your preferred browser.","title":"Gossamer Test Suite"},{"location":"testing-and-debugging/test-suite/#gossamer-integration-tests","text":"Running Gossamer's integration tests with the below commands will build a Gossamer binary, install required dependencies, and then proceeds to run the provided set of tests. Integration tests can also be run within a docker container. To run Gossamer integration tests in stress mode run the following command: make it-stress To run Gossamer integration tests against GRANDPA in stress mode run the following command: make it-grandpa To run Gossamer RPC integration tests run the following command: make it-rpc To run Gossamer Sync integration tests run the following command: make it-sync To run Gossamer Polkadot.js integration tests run the following command: make it-polkadotjs","title":"Gossamer Integration Tests"},{"location":"usage/command-line/","text":"Gossamer Command \u00b6 The gossamer command is the root command for the gossamer package ( cmd/gossamer ). The root command starts the node (and initialises the node if the node has not already been initialised). Accepted Formats \u00b6 gossamer [--global-flags] [--local-flags] gossamer [--local-flags] [--global-flags] Global flags \u00b6 The global flags can be used in conjunction with any Gossamer command -- basepath value Data directory for the node -- chain value Node implementation id used to load default node configuration -- config value TOML configuration file -- log value Supports levels crit ( silent ) to trce ( trace ) ( default : \"info\" ) -- name value Node implementation name -- rewind value Rewind head of chain by given number of blocks -- pprofserver Enable or disable the pprof HTTP server -- pprofaddress pprof HTTP server listening address , if it is enabled . -- pprofblockrate pprof block rate . See https : // pkg . go . dev / runtime #SetBlockProfileRate. -- pprofmutexrate profiling mutex rate . See https : // pkg . go . dev / runtime #SetMutexProfileFraction. Local flags \u00b6 These are the local flags that can be used with the gossamer command -- bootnodes value Comma separated enode URLs for network discovery bootstrap -- key value Specify a test keyring account to use : eg -- key = alice -- help , - h show help -- nobootstrap Disables network bootstrapping ( mdns still enabled ) -- nomdns Disables network mdns discovery -- port value Set network listening port ( default : 0 ) -- protocol value Set protocol id -- roles value Roles of the gossamer node -- rpc - external Enable the external HTTP - RPC server -- rpchost value HTTP - RPC server listening hostname -- rpcport value HTTP - RPC server listening port ( default : 0 ) -- rpcmods value API modules to enable via HTTP - RPC , comma separated list -- unlock value Unlock an account . eg . -- unlock = 0 , 2 to unlock accounts 0 and 2. Can be used with -- password =[ password ] to avoid prompt . For multiple passwords , do -- password = password1 , password2 -- ws - external Enable the external websockets server -- wsport value Websockets server listening port ( default : 0 ) --version, -v print the version Gossamer Subcommands \u00b6 List of available subcommands : SUBCOMMANDS : help , h Shows a list of commands or help for one command account Create and manage node keystore accounts export Export configuration values to TOML configuration file init Initialise node databases and load genesis data to state List of local flags for init subcommand: --force Disable all confirm prompts (the same as answering \"Y\" to all) --genesis value Path to genesis JSON file List of local flags for account subcommand: -- generate Generate a new keypair . If type is not specified , defaults to sr25519 -- password value Password used to encrypt the keystore . Used with -- generate or -- unlock -- import value Import encrypted keystore file generated with gossamer -- import - raw value Imports a raw private key -- list List node keys -- ed25519 Specify account type as ed25519 -- sr25519 Specify account type as sr25519 -- secp256k1 Specify account type as secp256k1 List of local flag options for export subcommand: -- force Disable all confirm prompts ( the same as answering \"Y\" to all ) -- genesis value Path to genesis JSON file -- key value Specify a test keyring account to use : eg -- key = alice -- unlock value Unlock an account . eg . -- unlock = 0 , 2 to unlock accounts 0 and 2. Can be used with -- password =[ password ] to avoid prompt . For multiple passwords , do -- password = password1 , password2 -- port value Set network listening port ( default : 0 ) -- bootnodes value Comma separated enode URLs for network discovery bootstrap -- protocol value Set protocol id -- roles value Roles of the gossamer node -- nobootstrap Disables network bootstrapping ( mdns still enabled ) -- nomdns Disables network mdns discovery -- rpc Enable the HTTP - RPC server -- rpc - external Enable external HTTP - RPC connections -- rpchost value HTTP - RPC server listening hostname -- rpcport value HTTP - RPC server listening port ( default : 0 ) -- rpcmods value API modules to enable via HTTP - RPC , comma separated list -- ws Enable the websockets server -- ws - external Enable external websockets connections --wsport value Websockets server listening port (default: 0) Accepted Formats \u00b6 gossamer [ --global-flags ] [ subcommand ] [ --local-flags ] gossamer [ subcommand ] [ --global-flags ] [ --local-flags ] gossamer [ subcommand ] [ --local-flags ] [ --global-flags ] Invalid Formats \u00b6 please note that [--local-flags] must come after [subcommand] gossamer [ --local-flags ] [ subcommand ] [ --global-flags ] gossamer [ --local-flags ] [ --global-flags ] [ subcommand ] gossamer [ --global-flags ] [ --local-flags ] [ subcommand ] Running Node Roles \u00b6 Run an authority node: ./bin/gossamer --key alice --roles 4 Run a non-authority node: ./bin/gossamer --key alice --roles 1 Running Multiple Nodes \u00b6 Two options for running another node at the same time... (1) copy the config file at cfg/gssmr/config.toml and manually update port and base-path : cp cfg/gssmr/config.toml cfg/gssmr/bob.toml # open bob.toml, set port=7002 and base-path=~/.gossamer/gssmr-bob # set roles=4 to also make bob an authority node, or roles=1 to make bob a non-authority node ./bin/gossamer --key bob --config cfg/gssmr/bob.toml or run with port, base-path flags: ./bin/gossmer --key bob --port 7002 --base-path ~/.gossamer/gssmr-bob --roles 4 To run more than two nodes, repeat steps for bob with a new port and base-path replacing bob . Available built-in keys: ./bin/gossmer --key alice ./bin/gossmer --key bob ./bin/gossmer --key charlie ./bin/gossmer --key dave ./bin/gossmer --key eve ./bin/gossmer --key ferdie ./bin/gossmer --key george ./bin/gossmer --key heather Initialising Nodes \u00b6 To initialise or re-initialise a node, use the init subcommand init : ./bin/gossamer init ./bin/gossamer --key alice --roles 4 init can be used with the --base-path or --config flag to re-initialise a custom node (ie, bob from the example above): ./bin/gossamer --config node/gssmr/bob.toml init Export Configuration \u00b6 export can be used with the gossamer root command-line and --config as the export path to export a toml configuration file.","title":"Command Line"},{"location":"usage/command-line/#gossamer-command","text":"The gossamer command is the root command for the gossamer package ( cmd/gossamer ). The root command starts the node (and initialises the node if the node has not already been initialised).","title":"Gossamer Command"},{"location":"usage/command-line/#accepted-formats","text":"gossamer [--global-flags] [--local-flags] gossamer [--local-flags] [--global-flags]","title":"Accepted Formats"},{"location":"usage/command-line/#global-flags","text":"The global flags can be used in conjunction with any Gossamer command -- basepath value Data directory for the node -- chain value Node implementation id used to load default node configuration -- config value TOML configuration file -- log value Supports levels crit ( silent ) to trce ( trace ) ( default : \"info\" ) -- name value Node implementation name -- rewind value Rewind head of chain by given number of blocks -- pprofserver Enable or disable the pprof HTTP server -- pprofaddress pprof HTTP server listening address , if it is enabled . -- pprofblockrate pprof block rate . See https : // pkg . go . dev / runtime #SetBlockProfileRate. -- pprofmutexrate profiling mutex rate . See https : // pkg . go . dev / runtime #SetMutexProfileFraction.","title":"Global flags"},{"location":"usage/command-line/#local-flags","text":"These are the local flags that can be used with the gossamer command -- bootnodes value Comma separated enode URLs for network discovery bootstrap -- key value Specify a test keyring account to use : eg -- key = alice -- help , - h show help -- nobootstrap Disables network bootstrapping ( mdns still enabled ) -- nomdns Disables network mdns discovery -- port value Set network listening port ( default : 0 ) -- protocol value Set protocol id -- roles value Roles of the gossamer node -- rpc - external Enable the external HTTP - RPC server -- rpchost value HTTP - RPC server listening hostname -- rpcport value HTTP - RPC server listening port ( default : 0 ) -- rpcmods value API modules to enable via HTTP - RPC , comma separated list -- unlock value Unlock an account . eg . -- unlock = 0 , 2 to unlock accounts 0 and 2. Can be used with -- password =[ password ] to avoid prompt . For multiple passwords , do -- password = password1 , password2 -- ws - external Enable the external websockets server -- wsport value Websockets server listening port ( default : 0 ) --version, -v print the version","title":"Local flags"},{"location":"usage/command-line/#gossamer-subcommands","text":"List of available subcommands : SUBCOMMANDS : help , h Shows a list of commands or help for one command account Create and manage node keystore accounts export Export configuration values to TOML configuration file init Initialise node databases and load genesis data to state List of local flags for init subcommand: --force Disable all confirm prompts (the same as answering \"Y\" to all) --genesis value Path to genesis JSON file List of local flags for account subcommand: -- generate Generate a new keypair . If type is not specified , defaults to sr25519 -- password value Password used to encrypt the keystore . Used with -- generate or -- unlock -- import value Import encrypted keystore file generated with gossamer -- import - raw value Imports a raw private key -- list List node keys -- ed25519 Specify account type as ed25519 -- sr25519 Specify account type as sr25519 -- secp256k1 Specify account type as secp256k1 List of local flag options for export subcommand: -- force Disable all confirm prompts ( the same as answering \"Y\" to all ) -- genesis value Path to genesis JSON file -- key value Specify a test keyring account to use : eg -- key = alice -- unlock value Unlock an account . eg . -- unlock = 0 , 2 to unlock accounts 0 and 2. Can be used with -- password =[ password ] to avoid prompt . For multiple passwords , do -- password = password1 , password2 -- port value Set network listening port ( default : 0 ) -- bootnodes value Comma separated enode URLs for network discovery bootstrap -- protocol value Set protocol id -- roles value Roles of the gossamer node -- nobootstrap Disables network bootstrapping ( mdns still enabled ) -- nomdns Disables network mdns discovery -- rpc Enable the HTTP - RPC server -- rpc - external Enable external HTTP - RPC connections -- rpchost value HTTP - RPC server listening hostname -- rpcport value HTTP - RPC server listening port ( default : 0 ) -- rpcmods value API modules to enable via HTTP - RPC , comma separated list -- ws Enable the websockets server -- ws - external Enable external websockets connections --wsport value Websockets server listening port (default: 0)","title":"Gossamer Subcommands"},{"location":"usage/command-line/#accepted-formats_1","text":"gossamer [ --global-flags ] [ subcommand ] [ --local-flags ] gossamer [ subcommand ] [ --global-flags ] [ --local-flags ] gossamer [ subcommand ] [ --local-flags ] [ --global-flags ]","title":"Accepted Formats"},{"location":"usage/command-line/#invalid-formats","text":"please note that [--local-flags] must come after [subcommand] gossamer [ --local-flags ] [ subcommand ] [ --global-flags ] gossamer [ --local-flags ] [ --global-flags ] [ subcommand ] gossamer [ --global-flags ] [ --local-flags ] [ subcommand ]","title":"Invalid Formats"},{"location":"usage/command-line/#running-node-roles","text":"Run an authority node: ./bin/gossamer --key alice --roles 4 Run a non-authority node: ./bin/gossamer --key alice --roles 1","title":"Running Node Roles"},{"location":"usage/command-line/#running-multiple-nodes","text":"Two options for running another node at the same time... (1) copy the config file at cfg/gssmr/config.toml and manually update port and base-path : cp cfg/gssmr/config.toml cfg/gssmr/bob.toml # open bob.toml, set port=7002 and base-path=~/.gossamer/gssmr-bob # set roles=4 to also make bob an authority node, or roles=1 to make bob a non-authority node ./bin/gossamer --key bob --config cfg/gssmr/bob.toml or run with port, base-path flags: ./bin/gossmer --key bob --port 7002 --base-path ~/.gossamer/gssmr-bob --roles 4 To run more than two nodes, repeat steps for bob with a new port and base-path replacing bob . Available built-in keys: ./bin/gossmer --key alice ./bin/gossmer --key bob ./bin/gossmer --key charlie ./bin/gossmer --key dave ./bin/gossmer --key eve ./bin/gossmer --key ferdie ./bin/gossmer --key george ./bin/gossmer --key heather","title":"Running Multiple Nodes"},{"location":"usage/command-line/#initialising-nodes","text":"To initialise or re-initialise a node, use the init subcommand init : ./bin/gossamer init ./bin/gossamer --key alice --roles 4 init can be used with the --base-path or --config flag to re-initialise a custom node (ie, bob from the example above): ./bin/gossamer --config node/gssmr/bob.toml init","title":"Initialising Nodes"},{"location":"usage/command-line/#export-configuration","text":"export can be used with the gossamer root command-line and --config as the export path to export a toml configuration file.","title":"Export Configuration"},{"location":"usage/configuration/","text":"Configuration \u00b6 Gossamer consumes a .toml file containing predefined settings for the node from setting the genesis file, to the RPC/WS server, this file allows you to curated the functionality of the node instead of writing out the flags manually Full reference \u00b6 [global] basepath = \"~/.gossamer/gssmr\" log = \" | trace | debug | info | warn | error | crit\" name = \"gssmr\" pprofserver = false pprofaddress = \":6060\" pprofblockrate = 0 pprofmutexrate = 0 [log] core = \" | trace | debug | info | warn | error | crit\" network = \" | trace | debug | info | warn | error | crit\" rpc = \" | trace | debug | info | warn | error | crit\" state = \" | trace | debug | info | warn | error | crit\" runtime = \" | trace | debug | info | warn | error | crit\" babe = \" | trace | debug | info | warn | error | crit\" grandpa = \" | trace | debug | info | warn | error | crit\" sync = \" | trace | debug | info | warn | error | crit\" [init] genesis-raw = \"./chain/gssmr/genesis-raw.json\" [account] key = \"\" unlock = \"\" [core] roles = 4 babe-authority = true grandpa-authority = true [network] port = 7001 nobootstrap = false nomdns = false [rpc] enabled = true | false external = true | false port = 8545 host = \"localhost\" modules = [ \"system\" , \"author\" , \"chain\" , \"state\" , \"rpc\" , \"grandpa\" ] ws = true | false ws-external = true | false ws-port = 8546","title":"Configuration"},{"location":"usage/configuration/#configuration","text":"Gossamer consumes a .toml file containing predefined settings for the node from setting the genesis file, to the RPC/WS server, this file allows you to curated the functionality of the node instead of writing out the flags manually","title":"Configuration"},{"location":"usage/configuration/#full-reference","text":"[global] basepath = \"~/.gossamer/gssmr\" log = \" | trace | debug | info | warn | error | crit\" name = \"gssmr\" pprofserver = false pprofaddress = \":6060\" pprofblockrate = 0 pprofmutexrate = 0 [log] core = \" | trace | debug | info | warn | error | crit\" network = \" | trace | debug | info | warn | error | crit\" rpc = \" | trace | debug | info | warn | error | crit\" state = \" | trace | debug | info | warn | error | crit\" runtime = \" | trace | debug | info | warn | error | crit\" babe = \" | trace | debug | info | warn | error | crit\" grandpa = \" | trace | debug | info | warn | error | crit\" sync = \" | trace | debug | info | warn | error | crit\" [init] genesis-raw = \"./chain/gssmr/genesis-raw.json\" [account] key = \"\" unlock = \"\" [core] roles = 4 babe-authority = true grandpa-authority = true [network] port = 7001 nobootstrap = false nomdns = false [rpc] enabled = true | false external = true | false port = 8545 host = \"localhost\" modules = [ \"system\" , \"author\" , \"chain\" , \"state\" , \"rpc\" , \"grandpa\" ] ws = true | false ws-external = true | false ws-port = 8546","title":"Full reference"},{"location":"usage/import-runtime/","text":"Launching a chain with a custom runtime \u00b6 The main use-case of the Polkadot Host is to create a standalone chain that may be converted to a parachain later. To do this, you need to have a compiled wasm runtime available for your chain. This can be created using FRAME , a domain-specific language used for creating runtimes. Once you have your runtime ready and compiled into a wasm binary, it is ready to be used with Gossamer. 1. Create genesis spec file with custom runtime \u00b6 You can use the gossamer import-runtime subcommand to create a genesis file containin g your custom runtime. The rest of the file is based off the gssmr genesis.json file. make gossamer . /bin/gossamer import - runtime <custom-runtime.wasm> > genesis-spec . json This creates a genesis spec file genesis-spec.json with the contents of your given file as the \"system\" \"code\" field. By default, genesis-spec.json will contain the 9 built-in keys as authorities with some preset balance. You can edit the fields as you wish. Note: the import-runtime subcommand does not validate that the runtime in the given file is valid. 2. Create raw genesis file from genesis spec \u00b6 To create the raw genesis file used by the node, you can use the gossamer build-spec subcommand. ./bin/gossamer build-spec --raw --genesis-spec genesis-spec.json > genesis.json or ./bin/gossamer build-spec --raw --genesis-spec genesis-spec.json --output genesis.json This creates a genesis file genesis.json that is usable by the node. 3. Initialise the node with the genesis file \u00b6 Next, you will need to write the state in genesis.json to the database by initialising the node. ./bin/gossamer init --genesis genesis.json The default basepath is ~/.gossamer/gssmr . If you wish you change this, you can specify the basepath with --basepath <path> . 4. Start the node \u00b6 The final step is to launch the node. This is the same as normal, providing a built-in authority key: ./bin/gossamer --key alice You now have a chain running a custom runtime!","title":"Import Runtime"},{"location":"usage/import-runtime/#launching-a-chain-with-a-custom-runtime","text":"The main use-case of the Polkadot Host is to create a standalone chain that may be converted to a parachain later. To do this, you need to have a compiled wasm runtime available for your chain. This can be created using FRAME , a domain-specific language used for creating runtimes. Once you have your runtime ready and compiled into a wasm binary, it is ready to be used with Gossamer.","title":"Launching a chain with a custom runtime"},{"location":"usage/import-runtime/#1-create-genesis-spec-file-with-custom-runtime","text":"You can use the gossamer import-runtime subcommand to create a genesis file containin g your custom runtime. The rest of the file is based off the gssmr genesis.json file. make gossamer . /bin/gossamer import - runtime <custom-runtime.wasm> > genesis-spec . json This creates a genesis spec file genesis-spec.json with the contents of your given file as the \"system\" \"code\" field. By default, genesis-spec.json will contain the 9 built-in keys as authorities with some preset balance. You can edit the fields as you wish. Note: the import-runtime subcommand does not validate that the runtime in the given file is valid.","title":"1. Create genesis spec file with custom runtime"},{"location":"usage/import-runtime/#2-create-raw-genesis-file-from-genesis-spec","text":"To create the raw genesis file used by the node, you can use the gossamer build-spec subcommand. ./bin/gossamer build-spec --raw --genesis-spec genesis-spec.json > genesis.json or ./bin/gossamer build-spec --raw --genesis-spec genesis-spec.json --output genesis.json This creates a genesis file genesis.json that is usable by the node.","title":"2. Create raw genesis file from genesis spec"},{"location":"usage/import-runtime/#3-initialise-the-node-with-the-genesis-file","text":"Next, you will need to write the state in genesis.json to the database by initialising the node. ./bin/gossamer init --genesis genesis.json The default basepath is ~/.gossamer/gssmr . If you wish you change this, you can specify the basepath with --basepath <path> .","title":"3. Initialise the node with the genesis file"},{"location":"usage/import-runtime/#4-start-the-node","text":"The final step is to launch the node. This is the same as normal, providing a built-in authority key: ./bin/gossamer --key alice You now have a chain running a custom runtime!","title":"4. Start the node"},{"location":"usage/import-state/","text":"Gossamer state import \u00b6 Importing state \u00b6 Gossamer supports the ability to import state exported from gossamer or substrate. To retrieve the state from an existing node, you will need to run the node in archive mode. For example, with Kusama: ./target/release/polkadot --chain=kusama --pruning archive --rpc-methods unsafe --rpc-port 8545 Since we will be using the RPC method state_getPairs which is marked unsafe , you will need to use the --rpc-methods unsafe option. Once the node has synced to the height you wish to export, you can export the state by first finding the block hash of the block you wish to export (can use polkascan.io) or RPC. For example, for block 1000: curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"chain_getBlockHash\", \"params\":[1000]}' http://localhost:8545 {\"jsonrpc\":\"2.0\",\"result\":\"0xcf36a1e4a16fc579136137b8388f35490f09c5bdd7b9133835eba907a8b76c30\",\"id\":1} For the following steps, you will need jq installed. Then, you can get the state at that block and redirect the output to a file state.json : curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"state_getPairs\", \"params\":[\"0x\", \"0xcf36a1e4a16fc579136137b8388f35490f09c5bdd7b9133835eba907a8b76c30\"]}' http://localhost:8545 | jq '.result' > state.json Then, get the header of the block: curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"chain_getHeader\", \"params\":[\"0xcf36a1e4a16fc579136137b8388f35490f09c5bdd7b9133835eba907a8b76c30\"]}' http://localhost:8545 | jq '.result' > header.json Lastly, get the first slot of the network. This can be find on polkascan.io. First, go to the network which you are importing then search for 1 (ie. block 1). Then, navigate to Logs -> PreRuntime -> Details . It will then show the slotNumber , for example, for Kusama, the first slot number is 262493679 : https://polkascan.io/kusama/log/1-0 Now you have all the required info to import the state into gossamer. In the gossamer directory: make gossamer . /bin/gossamer -- chain <chain-name> init -- force . /bin/gossamer import - state -- chain <chain-name> -- state state . json -- header header . json -- first-slot <first-slot> If you don't want to use a specific chain, but instead a custom data directory, you can use --basepath instead of --chain . If it is successful, you will see a finished state import log. Now, you can start the node as usual, and the node should begin from the imported state: ./bin/gossamer --chain <chain-name>","title":"Import State"},{"location":"usage/import-state/#gossamer-state-import","text":"","title":"Gossamer state import"},{"location":"usage/import-state/#importing-state","text":"Gossamer supports the ability to import state exported from gossamer or substrate. To retrieve the state from an existing node, you will need to run the node in archive mode. For example, with Kusama: ./target/release/polkadot --chain=kusama --pruning archive --rpc-methods unsafe --rpc-port 8545 Since we will be using the RPC method state_getPairs which is marked unsafe , you will need to use the --rpc-methods unsafe option. Once the node has synced to the height you wish to export, you can export the state by first finding the block hash of the block you wish to export (can use polkascan.io) or RPC. For example, for block 1000: curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"chain_getBlockHash\", \"params\":[1000]}' http://localhost:8545 {\"jsonrpc\":\"2.0\",\"result\":\"0xcf36a1e4a16fc579136137b8388f35490f09c5bdd7b9133835eba907a8b76c30\",\"id\":1} For the following steps, you will need jq installed. Then, you can get the state at that block and redirect the output to a file state.json : curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"state_getPairs\", \"params\":[\"0x\", \"0xcf36a1e4a16fc579136137b8388f35490f09c5bdd7b9133835eba907a8b76c30\"]}' http://localhost:8545 | jq '.result' > state.json Then, get the header of the block: curl -H \"Content-Type: application/json\" -d '{\"id\":1, \"jsonrpc\":\"2.0\", \"method\": \"chain_getHeader\", \"params\":[\"0xcf36a1e4a16fc579136137b8388f35490f09c5bdd7b9133835eba907a8b76c30\"]}' http://localhost:8545 | jq '.result' > header.json Lastly, get the first slot of the network. This can be find on polkascan.io. First, go to the network which you are importing then search for 1 (ie. block 1). Then, navigate to Logs -> PreRuntime -> Details . It will then show the slotNumber , for example, for Kusama, the first slot number is 262493679 : https://polkascan.io/kusama/log/1-0 Now you have all the required info to import the state into gossamer. In the gossamer directory: make gossamer . /bin/gossamer -- chain <chain-name> init -- force . /bin/gossamer import - state -- chain <chain-name> -- state state . json -- header header . json -- first-slot <first-slot> If you don't want to use a specific chain, but instead a custom data directory, you can use --basepath instead of --chain . If it is successful, you will see a finished state import log. Now, you can start the node as usual, and the node should begin from the imported state: ./bin/gossamer --chain <chain-name>","title":"Importing state"},{"location":"usage/running-nodes/","text":"Run a Gossamer Node \u00b6 To run default Gossamer node, first initialise the node. This writes the genesis state to the database. ./bin/gossamer --chain gssmr init The gossamer node runs as an authority by default. The built-in authorities are alice , bob , charlie , dave , eve , ferdie , george , and ian . To start the node as an authority, provide it with a built-in key: ./bin/gossamer --chain gssmr --key alice The node will not build blocks every slot by default; it will appear that the node is doing nothing, but it is actually waiting for a slot to build a block. If you wish to force it to build blocks every slot, you update the [core] section of chain/gssmr/config.toml to the following: [core] roles = 4 babe-authority = true grandpa-authority = true babe-threshold-numerator = 1 babe-threshold-denominator = 1 Then, re-run the above steps. NOTE: this feature is for testing only; if you wish to change the BABE block production parameters, you need to create a modified runtime. If you wish to run the default node as a non-authority, you can specify roles=1 : ./bin/gossamer --chain gssmr --roles 1 Run Kusama Node \u00b6 To run a Kusama node, first initialise the node: ./bin/gossamer --chain kusama init Then run the node selecting the Kusama chain: ./bin/gossamer --chain kusama The node may not appear to do anything for the first minute or so (it's bootstrapping to the network.) If you wish to see what is it doing in this time, you can turn on debug logs in chain/kusama/config.toml : [log] network = \"debug\" After it's finished bootstrapping, the node should begin to sync. Run Polkadot Node \u00b6 Initialise polkadot node: ./bin/gossamer --chain polkadot init Start polkadot node: ./bin/gossamer --chain polkadot Run Gossamer Node with Docker \u00b6 Gossamer can also be installed on GNU/Linux, MacOS systems with Docker. Dependencies \u00b6 Install the latest release of Docker Ensure you are running the most recent version of Docker by issuing the command: docker -v Pull the latest Gossamer images from DockerHub Registry: docker pull chainsafe/gossamer:latest The above command will install all required dependencies. Next, we need override the default entrypoint so we can run the node as an authority node docker run -it --entrypoint /bin/bash chainsafe/gossamer:latest The built-in authorities are alice , bob , charlie , dave , eve , ferdie , george , and ian . To start the node as an authority, provide it with a built-in key: ./bin/gossamer --chain gssmr --key alice","title":"Running Nodes"},{"location":"usage/running-nodes/#run-a-gossamer-node","text":"To run default Gossamer node, first initialise the node. This writes the genesis state to the database. ./bin/gossamer --chain gssmr init The gossamer node runs as an authority by default. The built-in authorities are alice , bob , charlie , dave , eve , ferdie , george , and ian . To start the node as an authority, provide it with a built-in key: ./bin/gossamer --chain gssmr --key alice The node will not build blocks every slot by default; it will appear that the node is doing nothing, but it is actually waiting for a slot to build a block. If you wish to force it to build blocks every slot, you update the [core] section of chain/gssmr/config.toml to the following: [core] roles = 4 babe-authority = true grandpa-authority = true babe-threshold-numerator = 1 babe-threshold-denominator = 1 Then, re-run the above steps. NOTE: this feature is for testing only; if you wish to change the BABE block production parameters, you need to create a modified runtime. If you wish to run the default node as a non-authority, you can specify roles=1 : ./bin/gossamer --chain gssmr --roles 1","title":"Run a Gossamer Node"},{"location":"usage/running-nodes/#run-kusama-node","text":"To run a Kusama node, first initialise the node: ./bin/gossamer --chain kusama init Then run the node selecting the Kusama chain: ./bin/gossamer --chain kusama The node may not appear to do anything for the first minute or so (it's bootstrapping to the network.) If you wish to see what is it doing in this time, you can turn on debug logs in chain/kusama/config.toml : [log] network = \"debug\" After it's finished bootstrapping, the node should begin to sync.","title":"Run Kusama Node"},{"location":"usage/running-nodes/#run-polkadot-node","text":"Initialise polkadot node: ./bin/gossamer --chain polkadot init Start polkadot node: ./bin/gossamer --chain polkadot","title":"Run Polkadot Node"},{"location":"usage/running-nodes/#run-gossamer-node-with-docker","text":"Gossamer can also be installed on GNU/Linux, MacOS systems with Docker.","title":"Run Gossamer Node with Docker"},{"location":"usage/running-nodes/#dependencies","text":"Install the latest release of Docker Ensure you are running the most recent version of Docker by issuing the command: docker -v Pull the latest Gossamer images from DockerHub Registry: docker pull chainsafe/gossamer:latest The above command will install all required dependencies. Next, we need override the default entrypoint so we can run the node as an authority node docker run -it --entrypoint /bin/bash chainsafe/gossamer:latest The built-in authorities are alice , bob , charlie , dave , eve , ferdie , george , and ian . To start the node as an authority, provide it with a built-in key: ./bin/gossamer --chain gssmr --key alice","title":"Dependencies"}]}